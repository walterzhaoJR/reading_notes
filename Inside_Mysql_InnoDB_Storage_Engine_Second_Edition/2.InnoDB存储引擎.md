# 第2章 InnoDB存储引擎

## 2.3InnoDB体系架构
### 2.3.2内存

#### 1.缓冲池

#### 2.LRU List、Free List、Flush List

* Innidb中的缓冲池可以看做很大的内存区域，通过LRU来管理
* LRU（最近最少使用）也就是最频繁使用的页在LRU列表的最前端
* Innodb缓冲池中的页大小为16K
* Innodb存储引擎对LRU算法进行了优化
  * 添加了midpoint（mid）位置：新读取的页不会插入到队列头，而是插到这个点。也就是innodb_old_blocks_pct这个变量。
  *  还有innodb_old_blocks_time这个参数用于表示读取到mid后需要等待多久才会被加入到LRU的热端。
* LRU用来管理已经读取的页。而db刚启动的时候，LRU为空，此时页都存放在Free列表中。
* 在LRU列表中也被修改过后，就称作为脏页，也就是缓冲池中的页和磁盘上的页的数据产生了不一致，此时db会通过CHECKPOINT机制将脏页刷新回磁盘，而Flush list中的页就是脏页。
* LRU管理缓冲池中可用的页，Flush用来管理将要刷新的页，二者互不影响。

#### 3.重做日志缓冲

* redo log buffer
* Innodb存储引擎将重做日志信息先放到这个缓冲区，然后按一定的频率刷新到重做日志文件

#### 4.额外的内存池

* Innodb存储引擎对内存的管理通过内存堆（heap）的方式进行。
* 对一些数据结构本身的内存分配，需要额外的内存池中进行。

### 2.4Checkpoint技术

* 应为数据库的缓冲池和重做日志不能无限增大，并且在出现异常，数据库需哟恢复数据的时候，如果完全恢复日志（很大）的话时间很长，所以需要在一定情况下将数据库的脏页强制刷到磁盘上。这个技术就是Checkpoint技术。
* Checkpoint技术解决的问题：
  * 缩短数据库恢复时间
  * 缓冲池不够时，将脏页刷到磁盘
  * 重做日志不可用时，刷脏页到磁盘
* 上边说到的重做日志不可用：用为数据库一般是循环使用重做日志的空间，重做日志不会无限增大，已经刷脏到磁盘的空间可以覆盖使用，但是如果可以覆盖的空间还是不够，就需要强制刷脏页。
* 两种Checkpoint
  * Sharp Checkpoint：发生在数据库关闭时
  * Fuzzy Checkpoint：发生在运行时

### 2.5Master Thread工作方式

#### 2.5.1 InnoDB1.0.x版本前的Master Thread

* Master Thread具有最高优先级的线程
* Master Thread会根据数据库运行状态在Loop ，background loop ，flush loop，suspend（暂停）loop中切换
* Loop为主循环，大多数操作都在其中，有两大部分操作：每秒钟和每10秒的操作：
  * 每秒的操作：
    * 日志缓冲刷新到磁盘，即使这个事务没有提交（将重做日志缓冲中的内容刷新到重做日志，这一点就是解释了为什么再大的事务commit夜很快）
    * 合并插入缓冲
    * 至多刷新100个innoDB的缓冲池中的脏页（可能）
    * 如果当前用户没有操作，切换到background loop
  * 每10秒进行的操作
    * 刷新100个脏页到磁盘（可能的话）
    * 合并至多5个插入缓冲（总是）
    * 将日志缓冲刷新到磁盘（总是）
    * 删除无用的undo页（总是）
    * 刷新100个或者10个脏页到磁盘（总是）
* background loop（后台循环）
  * 如果当前没有用户活动（数据库空闲）或者数据库关闭（shutdown）就会切换到这个循环
  * 会进行的操作：
    * 删除无用的Undo页（总是）
    * 合并20个插入缓冲（总是）
    * 跳回主循环（总是）
    * 不断刷新100个页直到符合条件（可能，跳转到flush loop）
  * 如何flush loop中没有操作，就会跳到 suspend loop（暂停），讲Master Thread挂起