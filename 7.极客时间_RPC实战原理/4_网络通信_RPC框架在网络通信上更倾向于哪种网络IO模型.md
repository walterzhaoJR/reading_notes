## 4_网络通信_RPC框架在网络通信上更倾向于哪种网络IO模型

#### 1.常见的网络通信模型
* 同步阻塞io
* 同步非阻塞io
* io多路复用
* 异步非阻塞io
* 其中除了异步io外，其余3中都是同步io

#### 2.同步阻塞io
* 是最基本，最简单的io模型
* linux 中默认的socket读写都是阻塞的
* 应用发起io调用 -> 应用进程被阻塞 -> 转到内核空间处理 -> 内核等待数据 -> 等到数据后 -> 将内核中的数据拷贝到用户内存中 -> io处理完毕 -> 解除进程阻塞状态
* 这里我们可以看到，系统内核处理 IO 操作分为两个阶段——等待数据和拷贝数据。而在这两个阶段中，应用进程中 IO 操作的线程会一直都处于阻塞状态，如果是基于 Java 多线程开发，那么每一个 IO 操作都要占用线程，直至 IO 操作结束。这个流程就好比我们去餐厅吃饭，我们到达餐厅，向服务员点餐，之后要一直在餐厅等待后厨将菜做好，然后服务员会将菜端给我们，我们才能享用。

#### 3.io多路复用
* 适合高并发模式
* 经典的 Reactor 模式也是基于此类 IO 模型
* 多个网络连接的io复用在一个复用器上，多个网络连接io可以注册到一个复用器（如select poll epoll上），当用户进程调用了select，整个进程被阻塞，同事内核会监听所有select上负责的socket，当任何一个socket中有数据准备好了。select就返回，这是用户进程再调用read将数据从内核拷贝到用户进程。这里我们可以看到，当用户进程发起了 select 调用，进程会被阻塞，当发现该 select 负责的 socket 有准备好的数据时才返回，之后才发起一次 read，整个流程要比阻塞 IO 要复杂，似乎也更浪费性能。但它最大的优势在于，用户可以在一个线程内同时处理多个 socket 的 IO 请求。用户可以注册多个 socket，然后不断地调用 select 读取被激活的 socket，即可达到在同一个线程内同时处理多个 IO 请求的目的。而在同步阻塞模型中，必须通过多线程的方式才能达到这个目的。
* 同样好比我们去餐厅吃饭，这次我们是几个人一起去的，我们专门留了一个人在餐厅排号等位，其他人就去逛街了，等排号的朋友通知我们可以吃饭了，我们就直接去享用了。

* 以上两种是最常用的网络io模型

#### 4.RPC 框架在网络通信上倾向选择哪种网络 IO 模型？
* RPC 调用在大多数的情况下，是一个高并发调用的场景，考虑到系统内核的支持、编程语言的支持以及 IO 模型本身的特点，在 RPC 框架的实现中，在网络通信的处理上，我们会选择 IO 多路复用的方式。

#### 5.什么是零拷贝
* 我们可以看到在网络io的过程中，要将数据在哦用户空间和内存空间中来回拷贝。也就是刚才讲阻塞 IO 的时候我讲到，系统内核处理 IO 操作分为两个阶段——等待数据和拷贝数据。等待数据，就是系统内核在等待网卡接收到数据后，把数据写到内核中；而拷贝数据，就是系统内核在获取到数据后，将数据拷贝到用户进程的空间中。
* 应用进程的每一次写操作，都会把数据写到用户空间的缓冲区中，再由 CPU 将数据拷贝到系统内核的缓冲区中，之后再由 DMA 将这份数据拷贝到网卡中，最后由网卡发送出去。这里我们可以看到，一次写操作数据要拷贝两次才能通过网卡发送出去，而用户进程的读操作则是将整个流程反过来，数据同样会拷贝两次才能让应用程序读取到数据。
* 应用进程的一次完整的读写操作，都需要在用户空间与内核空间中来回拷贝，并且每一次拷贝，都需要 CPU 进行一次上下文切换（由用户进程切换到系统内核，或由系统内核切换到用户进程），这样是不是很浪费 CPU 和性能呢？那有没有什么方式，可以减少进程间的数据拷贝，提高数据传输的效率呢？这时我们就需要零拷贝（Zero-copy）技术。
* 所谓的零拷贝，就是取消用户空间与内核空间之间的数据拷贝操作，应用进程每一次的读写操作，都可以通过一种方式，让应用进程向用户空间写入或者读取数据，就如同直接向内核空间写入或者读取数据一样，再通过 DMA 将内核中的数据拷贝到网卡，或将网卡中的数据 copy 到内核。
* 零拷贝有两种解决方式，分别是 mmap+write 方式和 sendfile 方式，mmap+write 方式的核心原理就是通过虚拟内存来解决的。
