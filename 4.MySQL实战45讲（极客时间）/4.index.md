# 4.深入浅出索引

* 索引的目的就是为了提高数据库查询效率，就像书的目录一样。

## 1.常见的索引类型

#### 1.1 可以用于提高读写效率的数据结构有很多，例如：哈希表，有序数据，搜索树

* 哈希表：
  * 是一种key-value存储结构
  * 思路简单，把值放在一个数组里，用哈希函数把key算出一个位置
  * 但是位置可能重复，所以就要拉出一个链表，把相同位置的元素不停的向后追加
  * 要知道一个key的value，就是先通过哈希函数处理key，然后再遍历链表。所以哈希表添加新元素快，只要追加，但是并不一定有序，所以哈希索引区间查询比较慢，要把区间中的所有key扫描一遍。
  * 所以哈希表适合在等值查找中使用
* 有序数组：
  * 在等值查找和范围查找方面都很优秀，可以通过二分查找，快速找到
  * 但是，如果要在中间位置插入数据，代价很高
  * 所以，有序数组适合静态数据，例如2017年某个城市的人口数（不再变化）
* 二叉搜索树：
  * 二叉搜索树的特点是：左儿子节点小于父节点，父节点小于右儿子节点，所以查询的效率是log(N)
  * 但是为了维持这个复杂度，要保证树是平衡二叉树，为了这个保证，更新的时间复杂度也是log(N)
  * 有二叉树，就有N叉树。多叉树，从左到右每个儿子节点大小递增，二叉树搜索效率最高
  * 二叉树虽然搜索小徐最高，但是存储相同节点要的树高最高，在机械磁盘时代，读一个数据块代价很高，为了减少磁盘读取，就要使用N叉树，这里的N取决于数据块的大小。
  * Innodb为例：N为1200左右。树高为4时，1200^3大概是17亿，访问一个10亿行的表上一个整数字段的索引，查找一个值，最多访问3次磁盘。
  * N叉树在读写上的优势，在数据库引擎中使用很多。

#### 1.2Innodb的索引模型

* 索引是在存储引擎层实现的
* innodb的表都是根据主键顺序以索引形式存放的，这种存储方式的表称为索引组织表，innodb使用B+树

索引模型。数据都存在B+树中，每一个索引都有一颗B+树。

* 根据叶子节点的内容，索引分为主键索引和非主键索引
* 主键索引的叶子节点保存整行数据，也被称为聚簇索引，非主键索引的叶子节点保存主键值，也被称作二级索引，非聚簇索引。
* 对于select * from table where k =10;的sql来说，基于非主键索引的查询要多查一棵B+树，先查非主键索引B+树，得到主键，再查主键索引B+树，得到数据
* 索引定位page，page中有个有序数组，通过二分查找定位行数据。

#### 1.3索引维护

* 如果插入数据的主键是递增的，只会在原有记录后边追加数据。
* 如果不是递增，而是在数据中间插入，就要挪动后边的数据，空出位置。
* 如果当数据页满了后，B+树的算法就要申请新的数据页，并且搬迁一部分数据过去，性能受影响，空间利用率也下降。这个是页的分裂。
* 如果有自增主键，就是讲自增列定义在主键上（NOT NULL PRIMARY KEY AUTO_INCREMENT），插入时可以不指定ID，系统自己将ID加1。这种递增插入不会涉及搬迁数据和触发叶子节点分裂。
* 并且，主键长度越小，索引约节省空间。因为非主键索引的叶子节点保存的是主键值。

### 自己的一些问题：

* DB索引里边的N叉树的N可以认为调整吗？